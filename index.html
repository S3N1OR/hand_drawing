<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi‑Person Pose — MoveNet (TF.js)</title>
  <!--
    Однофайловое демо: HTML + CSS + чистый JS.
    Зависимости через CDN:
      - @tensorflow/tfjs (latest)
      - @tensorflow-models/pose-detection (latest)

    ВАЖНО: доступ к камере работает ТОЛЬКО по HTTPS или http://localhost
  -->

  <!-- TF.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <!-- Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@latest"></script>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121821;
      --text: #e6edf3;
      --muted: #8b98a5;
      --accent: #3ea6ff;
      --danger: #ff5d5d;
      --ok: #2ecc71;
      --border: #1e2937;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 600px at 20% -10%, #122034 0%, transparent 60%),
                  radial-gradient(900px 500px at 120% 10%, #1a2435 0%, transparent 60%),
                  var(--bg);
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: rgba(18,24,33,0.9);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--border);
    }
    .toolbar {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      gap: 12px; padding: 12px 16px; align-items: center;
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .toolbar label { color: var(--muted); font-size: 12px; }
    select, button, input[type="checkbox"], input[type="range"] {
      appearance: none;
      background: #0f1622;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
    }
    select { min-width: 180px; }
    button { cursor: pointer; font-weight: 600; }
    button.primary { background: var(--accent); color: #0a0a0a; border-color: transparent; }
    button.danger { background: var(--danger); color: #0a0a0a; border-color: transparent; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .toggle { display: flex; gap: 8px; align-items: center; }
    .stats { color: var(--muted); font-size: 12px; }

    main { display: grid; place-items: center; padding: 16px; }
    .stage {
      position: relative; width: min(96vw, 1280px); aspect-ratio: 16/9; border: 1px solid var(--border);
      background: #0b0f14; border-radius: 12px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    canvas, video.renderer {
      position: absolute; inset: 0; width: 100%; height: 100%;
    }
    video.hidden-feed { position: fixed; left: -9999px; top: -9999px; width: 1px; height: 1px; opacity: 0; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center;
      background: linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.5));
      padding: 24px; text-align: center;
    }
    .overlay .card {
      width: min(640px, 92vw); background: rgba(20, 28, 40, 0.9); border: 1px solid var(--border);
      border-radius: 12px; padding: 20px; display: grid; gap: 14px;
    }
    .overlay h2 { margin: 0; font-size: 20px; }
    .overlay p { margin: 0; color: var(--muted); }

    footer { color: var(--muted); text-align: center; padding: 12px; border-top: 1px solid var(--border); }
    code { background: #0f1622; padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); }

    @media (max-width: 900px) {
      .toolbar { grid-template-columns: 1fr; gap: 8px; }
      select { min-width: 140px; }
      .stage { width: 98vw; aspect-ratio: 3/4; }
    }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <div class="row">
        <button id="btnStart" class="primary">Start Camera</button>
        <button id="btnStop" class="danger" disabled>Stop</button>
        <span class="stats" id="status">Готово</span>
      </div>
      <div class="row">
        <label>
          Камера:
          <select id="cameraSelect"></select>
        </label>
        <label>
          Разрешение:
          <select id="resSelect">
            <option value="640x480">640×480</option>
            <option value="1280x720" selected>1280×720</option>
            <option value="1920x1080">1920×1080</option>
          </select>
        </label>
      </div>
      <div class="row">
        <label class="toggle"><input type="checkbox" id="chkPoints" checked/> Показать точки</label>
        <label class="toggle"><input type="checkbox" id="chkBones" checked/> Показать кости</label>
        <label class="toggle"><input type="checkbox" id="chkBoxes"/> Рамки</label>
        <label class="toggle"><input type="checkbox" id="chkFPS" checked/> FPS</label>
      </div>
      <div class="row">
        <label>
          Порог уверенности: <span id="threshVal">0.30</span>
          <input type="range" id="confThresh" min="0" max="1" step="0.05" value="0.30" />
        </label>
      </div>
    </div>
  </header>

  <main>
    <div class="stage" id="stage">
      <!-- Скрытый <video> — источник кадров (камера или демо) -->
      <video id="video" class="hidden-feed" playsinline muted></video>

      <!-- Канвас отрисовки скелета -->
      <canvas id="canvas" class="renderer"></canvas>

      <!-- Приватность: оверлей до первого старта -->
      <div id="privacyOverlay" class="overlay" hidden>
        <div class="card">
          <h2>Доступ к камере</h2>
          <p>Сайт использует вашу камеру <strong>только локально</strong> в браузере. Ничего не отправляется на сервер.</p>
          <div class="row" style="justify-content:center;">
            <button id="btnAllow" class="primary">Разрешить камеру</button>
            <button id="btnDemo">Воспроизвести демо</button>
          </div>
          <p style="font-size:12px">Если камера не работает — откройте страницу по HTTPS или <code>http://localhost</code>.</p>
        </div>
      </div>

      <!-- Блок ошибок/сообщений -->
      <div id="messageOverlay" class="overlay" hidden>
        <div class="card">
          <h2 id="msgTitle">Сообщение</h2>
          <p id="msgText">Текст сообщения…</p>
          <div class="row" style="justify-content:center;">
            <button id="msgClose">Ок</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <p>
      Подсказка: для доступа к камере нужен HTTPS или <code>http://localhost</code>. На iOS Safari разрешите доступ к камере в настройках сайта.
    </p>
  </footer>

<script>
(() => {
  // ======= Константы и состояние =======
  const CONF_DEFAULT = 0.30; // порог уверенности по умолчанию
  const MAX_POSES = 6;       // максимальное количество людей
  const COLORS = [
    '#3ea6ff','#ff6b6b','#ffd166','#06d6a0','#a78bfa','#f472b6','#f59e0b','#34d399'
  ];

  const els = {
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    status: document.getElementById('status'),
    cameraSelect: document.getElementById('cameraSelect'),
    resSelect: document.getElementById('resSelect'),
    chkPoints: document.getElementById('chkPoints'),
    chkBones: document.getElementById('chkBones'),
    chkBoxes: document.getElementById('chkBoxes'),
    chkFPS: document.getElementById('chkFPS'),
    confThresh: document.getElementById('confThresh'),
    threshVal: document.getElementById('threshVal'),
    video: document.getElementById('video'),
    canvas: document.getElementById('canvas'),
    privacyOverlay: document.getElementById('privacyOverlay'),
    btnAllow: document.getElementById('btnAllow'),
    btnDemo: document.getElementById('btnDemo'),
    msgOverlay: document.getElementById('messageOverlay'),
    msgTitle: document.getElementById('msgTitle'),
    msgText: document.getElementById('msgText'),
    msgClose: document.getElementById('msgClose'),
  };

  const ctx = els.canvas.getContext('2d');
  let offscreen = null; // optional OffscreenCanvas
  let stream = null;
  let detector = null;
  let running = false;
  let rafId = 0;
  let lastFrameTime = performance.now();
  let fps = 0, latencyMs = 0;

  // Скелет: пары ключевых точек (имена MoveNet 17kp)
  // Стандартные связи: плечевой пояс, руки, таз, ноги, уши к плечам
  const EDGES = [
    ['left_ear','left_shoulder'], ['right_ear','right_shoulder'],
    ['left_shoulder','right_shoulder'],
    ['left_shoulder','left_elbow'], ['left_elbow','left_wrist'],
    ['right_shoulder','right_elbow'], ['right_elbow','right_wrist'],
    ['left_shoulder','left_hip'], ['right_shoulder','right_hip'],
    ['left_hip','right_hip'],
    ['left_hip','left_knee'], ['left_knee','left_ankle'],
    ['right_hip','right_knee'], ['right_knee','right_ankle'],
    ['nose','left_eye'], ['nose','right_eye'],
    ['left_eye','left_ear'], ['right_eye','right_ear']
  ];

  // ======= Утилиты =======
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function log(msg) { els.status.textContent = msg; }

  function setRunningUI(isOn) {
    els.btnStart.disabled = isOn;
    els.btnStop.disabled = !isOn;
    els.cameraSelect.disabled = isOn;
    els.resSelect.disabled = isOn;
  }

  function parseRes(value) {
    const [w,h] = value.split('x').map(Number);
    return { width: w, height: h };
  }

  function colorForIndex(i) { return COLORS[i % COLORS.length]; }

  function showOverlay(title, text) {
    els.msgTitle.textContent = title;
    els.msgText.textContent = text;
    els.msgOverlay.hidden = false;
  }
  function hideOverlay() { els.msgOverlay.hidden = true; }

  function ensureCanvasSize(w, h) {
    // Сохраняем соотношение сторон рамки (вписываем видео в канвас без искажений)
    const stage = document.getElementById('stage');
    const stageW = stage.clientWidth;
    const stageH = stage.clientHeight;
    const videoAR = w / h;
    let drawW = stageW, drawH = Math.round(stageW / videoAR);
    if (drawH > stageH) { drawH = stageH; drawW = Math.round(stageH * videoAR); }

    els.canvas.width = drawW;
    els.canvas.height = drawH;
    els.canvas.style.width = drawW + 'px';
    els.canvas.style.height = drawH + 'px';

    // Подготовим OffscreenCanvas (опционально)
    if ('OffscreenCanvas' in window) {
      offscreen = new OffscreenCanvas(drawW, drawH);
    } else {
      offscreen = null;
    }
  }

  async function enumerateCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      els.cameraSelect.innerHTML = '';
      cams.forEach((c, i) => {
        const opt = document.createElement('option');
        opt.value = c.deviceId;
        opt.textContent = c.label || `Камера ${i+1}`;
        els.cameraSelect.appendChild(opt);
      });
      if (cams.length === 0) {
        showOverlay('Камера не найдена', 'Не обнаружено видеоустройств. Подключите камеру и перезагрузите страницу.');
      }
    } catch (e) {
      console.error('enumerateDevices error', e);
      showOverlay('Ошибка доступа к устройствам', String(e?.message || e));
    }
  }

  async function initCamera() {
    const { width, height } = parseRes(els.resSelect.value);
    const deviceId = els.cameraSelect.value || undefined;

    const constraints = {
      audio: false,
      video: {
        width: { ideal: width },
        height: { ideal: height },
        frameRate: { ideal: 30, max: 60 },
        ...(deviceId ? { deviceId: { exact: deviceId } } : {})
      }
    };

    try {
      if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia не поддерживается этим браузером');
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      els.video.srcObject = stream;
      await els.video.play();
      // Ждём метаданные, чтобы узнать реальный размер фида
      if (els.video.readyState < 2) await new Promise(res => els.video.onloadedmetadata = res);
      ensureCanvasSize(els.video.videoWidth, els.video.videoHeight);
      log(`Камера ${els.video.videoWidth}×${els.video.videoHeight} запущена`);
      return true;
    } catch (e) {
      console.error('initCamera error', e);
      showOverlay('Нет доступа к камере', 'Предоставьте доступ к камере, либо используйте демо. ' + (e?.message || e));
      return false;
    }
  }

  async function initDetector() {
    try {
      await tf.ready();
      // Явно активируем WebGL, если доступно
      if (tf.backend() !== 'webgl' && tf.engine().registryFactory['webgl']) {
        await tf.setBackend('webgl');
        await tf.ready();
      }
      const { SupportedModels, movenet } = poseDetection;
      detector = await poseDetection.createDetector(SupportedModels.MoveNet, {
        modelType: movenet.modelType.MULTIPOSE_LIGHTNING,
        enableSmoothing: true
      });
      return true;
    } catch (e) {
      console.error('initDetector error', e);
      showOverlay('Ошибка загрузки модели', 'Не удалось загрузить MoveNet MultiPose. ' + (e?.message || e));
      return false;
    }
  }

  function stopCamera() {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
  }

  async function disposeDetector() {
    if (detector) {
      try { await detector.dispose(); } catch(e) { /* ignore */ }
      detector = null;
    }
  }

  function drawCircle(g, x, y, r) {
    g.beginPath(); g.arc(x, y, r, 0, Math.PI*2); g.fill();
  }

  function projectPoint(x, y, srcW, srcH, dstW, dstH) {
    // Видео вписано в канвас с сохранением AR. Считаем letterbox отступы
    const srcAR = srcW / srcH; const dstAR = dstW / dstH;
    let scale, offsetX = 0, offsetY = 0;
    if (srcAR > dstAR) {
      // ограничено по ширине
      scale = dstW / srcW;
      offsetY = (dstH - srcH * scale) / 2;
    } else {
      // ограничено по высоте
      scale = dstH / srcH;
      offsetX = (dstW - srcW * scale) / 2;
    }
    return { x: x * scale + offsetX, y: y * scale + offsetY };
  }

  function drawBoxes(g, pose, color, srcW, srcH, dstW, dstH, thresh) {
    const pts = pose.keypoints.filter(k=> (k.score??1) >= thresh);
    if (!pts.length) return;
    let minX=1e9, minY=1e9, maxX=-1e9, maxY=-1e9;
    for (const k of pts) { minX=Math.min(minX,k.x); minY=Math.min(minY,k.y); maxX=Math.max(maxX,k.x); maxY=Math.max(maxY,k.y); }
    const p1 = projectPoint(minX, minY, srcW, srcH, dstW, dstH);
    const p2 = projectPoint(maxX, maxY, srcW, srcH, dstW, dstH);
    g.strokeStyle = color; g.lineWidth = 2; g.strokeRect(p1.x, p1.y, p2.x-p1.x, p2.y-p1.y);
  }

  function drawKeypoints(g, pose, color, srcW, srcH, dstW, dstH, thresh) {
    g.fillStyle = color;
    for (const k of pose.keypoints) {
      const sc = k.score ?? 1; if (sc < thresh) continue;
      const p = projectPoint(k.x, k.y, srcW, srcH, dstW, dstH);
      drawCircle(g, p.x, p.y, 3);
    }
  }

  function drawSkeleton(g, pose, color, srcW, srcH, dstW, dstH, thresh) {
    g.strokeStyle = color; g.lineWidth = 2;
    const byName = {};
    for (const k of pose.keypoints) byName[k.name||k.part||k.keypointType||''] = k;
    for (const [a,b] of EDGES) {
      const ka = byName[a], kb = byName[b];
      if (!ka || !kb) continue;
      if ((ka.score??1) < thresh || (kb.score??1) < thresh) continue;
      const p1 = projectPoint(ka.x, ka.y, srcW, srcH, els.canvas.width, els.canvas.height);
      const p2 = projectPoint(kb.x, kb.y, srcW, srcH, els.canvas.width, els.canvas.height);
      g.beginPath(); g.moveTo(p1.x, p1.y); g.lineTo(p2.x, p2.y); g.stroke();
    }
  }

  function drawHUD(g, peopleCount) {
    if (!els.chkFPS.checked) return;
    g.fillStyle = 'rgba(0,0,0,.55)';
    g.fillRect(8, 8, 190, 54);
    g.fillStyle = '#e6edf3';
    g.font = '12px system-ui, sans-serif';
    g.fillText(`FPS: ${fps.toFixed(1)}`, 16, 26);
    g.fillText(`Latency: ${Math.round(latencyMs)} ms`, 16, 42);
    g.fillText(`People: ${peopleCount}`, 110, 26);
  }

  async function loop() {
    if (!running) return;
    const t0 = performance.now();
    const v = els.video;
    const srcW = v.videoWidth, srcH = v.videoHeight;
    if (!srcW || !srcH) { rafId = requestAnimationFrame(loop); return; }

    const thresh = parseFloat(els.confThresh.value) || CONF_DEFAULT;

    let poses = [];
    if (detector) {
      try {
        poses = await detector.estimatePoses(v, { maxPoses: MAX_POSES, flipHorizontal: false });
      } catch (e) {
        console.warn('estimatePoses error', e);
      }
    }

    // Рисуем в offscreen (если доступен) для снижения нагрузки
    const g = offscreen ? offscreen.getContext('2d') : ctx;
    const dstW = els.canvas.width, dstH = els.canvas.height;

    g.clearRect(0, 0, dstW, dstH);
    // Можно отрисовать исходное видео как фон (по желанию). Здесь рисуем приглушенный фон.
    try {
      g.globalAlpha = 0.18; g.drawImage(v, 0, 0, dstW, dstH); g.globalAlpha = 1;
    } catch {}

    // Отрисовка для каждого обнаруженного человека
    poses.forEach((pose, idx) => {
      const color = colorForIndex(idx);
      if (els.chkBoxes.checked) drawBoxes(g, pose, color, srcW, srcH, dstW, dstH, thresh);
      if (els.chkBones.checked) drawSkeleton(g, pose, color, srcW, srcH, dstW, dstH, thresh);
      if (els.chkPoints.checked) drawKeypoints(g, pose, color, srcW, srcH, dstW, dstH, thresh);
    });

    drawHUD(g, poses.length);

    // Копируем из offscreen на видимый канвас
    if (offscreen) {
      ctx.clearRect(0,0,dstW,dstH);
      ctx.drawImage(offscreen, 0, 0);
    }

    // FPS/latency
    const t1 = performance.now();
    latencyMs = t1 - t0;
    const dt = t1 - lastFrameTime; lastFrameTime = t1;
    fps = fps * 0.9 + (1000/dt) * 0.1;

    rafId = requestAnimationFrame(loop);
  }

  async function start() {
    // Показать оверлей приватности при первом запуске
    els.privacyOverlay.hidden = false;
  }

  async function startCameraSession() {
    hideOverlay();
    setRunningUI(true);
    log('Инициализация…');

    // Убедимся, что список камер заполнен (Safari может требовать разрешения заранее)
    try {
      if (!els.cameraSelect.options.length) {
        await enumerateCameras();
      }
    } catch {}

    const okCam = await initCamera();
    if (!okCam) { setRunningUI(false); return; }

    const okDet = await initDetector();
    if (!okDet) { setRunningUI(false); return; }

    running = true; fps = 0; lastFrameTime = performance.now();
    loop();
    log('Работает');
  }

  async function stop() {
    running = false;
    cancelAnimationFrame(rafId);
    await disposeDetector();
    stopCamera();
    setRunningUI(false);
    log('Остановлено');
  }

  // ======= Обработчики UI =======
  els.btnStart.addEventListener('click', () => start());
  els.btnStop.addEventListener('click', () => stop());
  els.btnAllow.addEventListener('click', () => startCameraSession());
  els.btnDemo.addEventListener('click', () => {
    // Демо-режим без камеры: показываем сообщение.
    // (Можно заменить на встроенное видео data:URL, если доступно.)
    showOverlay('Демо недоступно', 'Камера недоступна. Это демо без видео: модель требует видеопотока.');
  });
  els.msgClose.addEventListener('click', hideOverlay);

  els.confThresh.addEventListener('input', () => {
    els.threshVal.textContent = Number(els.confThresh.value).toFixed(2);
  });

  // Изменение разрешения — перезапускаем при активной сессии
  els.resSelect.addEventListener('change', async () => {
    if (!running) return; await stop(); await startCameraSession();
  });
  els.cameraSelect.addEventListener('change', async () => {
    if (!running) return; await stop(); await startCameraSession();
  });

  // Инициализация списка камер (если разрешение уже было предоставлено ранее — будут видны label'ы)
  (async () => {
    try {
      await enumerateCameras();
    } catch {}
  })();

  // Корректируем размер канваса при изменении размера окна
  window.addEventListener('resize', () => {
    const v = els.video;
    if (v.videoWidth && v.videoHeight) ensureCanvasSize(v.videoWidth, v.videoHeight);
  });
})();
</script>

<!--
ИНСТРУКЦИИ ПО ЗАПУСКУ
1) Открыть файл напрямую двойным кликом: большинство браузеров запретят доступ к камере с file://
2) Рекомендуется:
   - Поднять локальный сервер:  python -m http.server 8000
   - Открыть: http://localhost:8000  (доступ к камере будет разрешён)
3) В продакшене используйте HTTPS.
-->
</body>
</html>
