<!DOCTYPE html> <html lang="ru"> <head> <meta charset="UTF-8" /> <title>Multi-Person Pose — MoveNet (TF.js)</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <!-- NOTE: Для доступа к камере нужен HTTPS или http://localhost --> <!-- TensorFlow.js + Pose Detection (latest) --> <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script> <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@latest"></script> <style> :root { --bg: #0c0f14; --panel: #121722; --text: #e6eaf2; --muted: #9aa4b2; --accent: #3b82f6; --danger: #ef4444; --border: #222a38; --good: #22c55e; } * { box-sizing: border-box; } html, body { height: 100%; margin: 0; } body { font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; color: var(--text); background: radial-gradient(1200px 800px at 20% 10%, #0f172a 0%, #0c0f14 45%, #0b0e13 100%); } /* Верхняя панель управления */ .toolbar { position: sticky; top: 0; z-index: 10; background: rgba(18, 23, 34, 0.9); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); padding: 10px 14px; } .row { display: flex; flex-wrap: wrap; gap: 10px 14px; align-items: center; } .toolbar .group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding: 6px 10px; border: 1px solid var(--border); border-radius: 10px; background: #0e1420; } label { color: var(--muted); } select, input[type="checkbox"] { accent-color: var(--accent); } select, button { background: #0a1220; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 8px 10px; } button { cursor: pointer; } button.primary { background: var(--accent); border-color: var(--accent); color: white; } button.ghost { background: transparent; } .container { max-width: 1200px; margin: 16px auto; padding: 0 14px 60px; display: grid; grid-template-columns: 1fr; gap: 16px; } .stage { position: relative; display: grid; place-items: center; background: #0a0f18; border: 1px solid var(--border); border-radius: 14px; overflow: hidden; min-height: 320px; } canvas { width: 100%; height: auto; display: block; image-rendering: auto; } /* Скрытое видео для чтения кадров */ video#camera, video#demo { position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none; } .stats { position: absolute; left: 12px; bottom: 12px; padding: 6px 10px; border-radius: 10px; background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.08); color: #dbe3ef; font-size: 12px; } .badge { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 999px; background: rgba(59,130,246,0.15); border: 1px solid rgba(59,130,246,0.35); color: #bcd7ff; font-size: 12px; margin-right: 6px; } /* Оверлей приватности */ .overlay { position: fixed; inset: 0; background: rgba(6,10,18,0.8); backdrop-filter: blur(8px); display: grid; place-items: center; z-index: 20; } .overlay .card { width: min(560px, 92vw); background: #0f1625; border: 1px solid var(--border); border-radius: 16px; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); } .overlay h2 { margin: 0 0 8px; font-weight: 700; } .overlay p { margin: 0 0 16px; color: var(--muted); } .overlay .actions { display: flex; gap: 10px; flex-wrap: wrap; } .hint { color: var(--muted); text-align: center; margin-top: -6px; } .footer-note { color: var(--muted); text-align: center; font-size: 12px; } @media (min-width: 992px) { .container { grid-template-columns: 1fr; } } </style> </head> <body> <!-- Верхняя панель --> <div class="toolbar"> <div class="row"> <div class="group"> <button id="btnToggle" class="primary">Start Camera</button> <button id="btnDemo" class="ghost" title="Если камера недоступна">Воспроизвести демо</button> </div>
    <div class="group">
    <label for="selCamera">Камера</label>
    <select id="selCamera"></select>

    <label for="selRes">Разрешение</label>
    <select id="selRes">
      <option value="640x480">640×480</option>
      <option value="1280x720" selected>1280×720</option>
      <option value="1920x1080">1920×1080</option>
    </select>
  </div>

  <div class="group">
    <label><input type="checkbox" id="chkPoints" checked /> Показать точки</label>
    <label><input type="checkbox" id="chkBones" checked /> Показать кости</label>
    <label><input type="checkbox" id="chkBoxes" /> Показать рамки</label>
    <label><input type="checkbox" id="chkFPS" checked /> Показать FPS</label>
  </div>

  <div class="group">
    <label for="conf">Порог уверенности</label>
    <input id="conf" type="range" min="0" max="1" step="0.05" value="0.3" />
    <span id="confVal">0.30</span>
  </div>
</div>
</div> <div class="container"> <div class="stage"> <!-- Скрытые видеопотоки --> <video id="camera" playsinline muted></video> <video id="demo" playsinline muted loop></video>
    <!-- Основной холст -->
  <canvas id="canvas" width="1280" height="720"></canvas>

  <!-- Индикаторы -->
  <div class="stats" id="stats">
    <span class="badge" title="FPS">FPS: <strong id="fps">0</strong></span>
    <span class="badge" title="Задержка кадра (мс)">Δt: <strong id="dt">0</strong> ms</span>
    <span class="badge" title="Обнаружено людей">People: <strong id="people">0</strong></span>
    <span class="badge" title="Бэкенд TF.js"><strong id="backend">-</strong></span>
  </div>
</div>

<p class="hint">Если не работает камера — откройте сайт по <strong>HTTPS</strong> или <code>http://localhost</code>. На iOS Safari разрешите доступ в настройках.</p>
<p class="footer-note">Модель: MoveNet MultiPose (Lightning). Обработка выполняется локально в вашем браузере.</p>
</div> <!-- Оверлей приватности / первый старт --> <div class="overlay" id="overlay"> <div class="card"> <h2>Доступ к камере</h2> <p>Сайт использует вашу камеру <strong>только локально</strong> в браузере. Ничего не отправляется на сервер.</p> <div class="actions"> <button id="allowBtn" class="primary">Разрешить камеру</button> <button id="denyBtn">Отмена</button> </div> <p class="footer-note" style="margin-top:10px;">Совет: для работы камеры используйте HTTPS или <code>http://localhost</code>.</p> </div> </div> <script> // ========================== // Конфигурация и состояние // ========================== const STATE = { running: false, usingDemo: false, videoEl: null, stream: null, detector: null, rafId: null, maxPoses: 6, confThreshold: 0.30, options: { showPoints: true, showBones: true, showBoxes: false, showFPS: true }, lastTime: performance.now(), fps: 0, dt: 0 }; // Поддержка OffscreenCanvas (не ломаем iOS) const supportsOffscreen = typeof OffscreenCanvas !== 'undefined'; const videoEl = document.getElementById('camera'); const demoEl = document.getElementById('demo'); const canvas = document.getElementById('canvas'); let ctx = canvas.getContext('2d', { willReadFrequently: false }); // Элементы UI const btnToggle = document.getElementById('btnToggle'); const btnDemo = document.getElementById('btnDemo'); const selCamera = document.getElementById('selCamera'); const selRes = document.getElementById('selRes'); const chkPoints = document.getElementById('chkPoints'); const chkBones = document.getElementById('chkBones'); const chkBoxes = document.getElementById('chkBoxes'); const chkFPS = document.getElementById('chkFPS'); const confRange = document.getElementById('conf'); const confVal = document.getElementById('confVal'); const fpsEl = document.getElementById('fps'); const dtEl = document.getElementById('dt'); const peopleEl = document.getElementById('people'); const backendEl = document.getElementById('backend'); const overlay = document.getElementById('overlay'); const allowBtn = document.getElementById('allowBtn'); const denyBtn = document.getElementById('denyBtn'); // Небольшое учебное демо-видео (микро WebM, 1.2 кБ, просто чёрный экран) — как заглушка // Если камера недоступна, можно нажать "Воспроизвести демо". На нём модель скорее всего никого не найдёт — это ок. const TINY_WEBM_DATA_URL = 'data:video/webm;base64,GkXfo59ChoEBQveBAULykQFZQGZ0eXBhcHBsY2F0LndlYm0AAAAAAABZAEAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAGQAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9AAAAAAAcQAAAB9HJ6f///+WAAAAAAAAGGZpcGNtAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'; // ========================== // Инициализация // ========================== (async function init() { // Обновляем отображение порога confVal.textContent = Number(STATE.confThreshold).toFixed(2); // Пытаемся выбрать бэкенд WebGL, если доступен try { // tf is global from CDN await tf.setBackend('webgl'); await tf.ready(); } catch(e) { console.warn('TF.js backend set failed, falling back:', e); } finally { backendEl.textContent = tf.getBackend(); } // Заполняем список камер (если доступно) await populateCameras(); // Установим демо-источник demoEl.src = TINY_WEBM_DATA_URL; // Слушатели UI btnToggle.addEventListener('click', onToggleCamera); btnDemo.addEventListener('click', onPlayDemo); allowBtn.addEventListener('click', async () => { overlay.style.display = 'none'; if (!STATE.running) await startCamera(); }); denyBtn.addEventListener('click', () => overlay.style.display = 'none'); selCamera.addEventListener('change', async () => { if (STATE.running && !STATE.usingDemo) { await restartCamera(); } }); selRes.addEventListener('change', async () => { if (STATE.running && !STATE.usingDemo) { await restartCamera(); } }); chkPoints.addEventListener('change', () => STATE.options.showPoints = chkPoints.checked); chkBones .addEventListener('change', () => STATE.options.showBones = chkBones.checked); chkBoxes .addEventListener('change', () => STATE.options.showBoxes = chkBoxes.checked); chkFPS addEventListener('change', () => STATE.options.showFPS = chkFPS.checked); confRange.addEventListener('input', (e) => { STATE.confThreshold = Number(e.target.value); confVal.textContent = STATE.confThreshold.toFixed(2); }); })(); async function populateCameras() { selCamera.innerHTML = ''; try { // Для enumerateDevices нужен хотя бы один getUserMedia на некоторых браузерах — обойдёмся как есть const devices = await navigator.mediaDevices.enumerateDevices(); const cams = devices.filter(d => d.kind === 'videoinput'); if (cams.length === 0) { selCamera.innerHTML = `<option value="">Камера не найдена</option>`; return; } cams.forEach((cam, idx) => { const opt = document.createElement('option'); opt.value = cam.deviceId; opt.textContent = cam.label || `Камера ${idx + 1}`; selCamera.appendChild(opt); }); } catch (e) { console.warn('enumerateDevices error:', e); selCamera.innerHTML = `<option value="">Нет доступа к устройствам</option>`; } } function parseResolution(value) { const [w, h] = value.split('x').map(Number); return { width: w || 1280, height: h || 720 }; } function setCanvasSize(w, h) { // Размер буфера канваса = реальному размеру видео canvas.width = w; canvas.height = h; } function getConstraints() { const { width, height } = parseResolution(selRes.value || '1280x720'); const deviceId = selCamera.value; const video = { width: { ideal: width }, height: { ideal: height }, facingMode: 'user' // можно поменять на 'environment' для задней камеры на мобилках }; if (deviceId) video.deviceId = { exact: deviceId }; return { audio: false, video }; } async function startCamera() { STATE.usingDemo = false; try { stopEverything(); // очистка на всякий случай const constraints = getConstraints(); const stream = await navigator.mediaDevices.getUserMedia(constraints); videoEl.srcObject = stream; STATE.stream = stream; await videoEl.play(); STATE.videoEl = videoEl; // Ждём метаданные, чтобы узнать размеры кадра await new Promise(res => { if (videoEl.readyState >= 2) return res(); videoEl.onloadedmetadata = () => res(); }); setCanvasSize(videoEl.videoWidth, videoEl.videoHeight); await ensureDetector(); btnToggle.textContent = 'Stop Camera'; STATE.running = true; requestDraw(); } catch (e) { console.error('Camera start error:', e); alert(humanizeMediaError(e) + '\nМожно запустить демо-видео (кнопка в панели).'); } } async function restartCamera() { await startCamera(); } async function onToggleCamera() { if (!STATE.running) { // Показать оверлей приватности при первом старте overlay.style.display = 'grid'; } else { stopEverything(); } } async function onPlayDemo() { try { stopEverything(); demoEl.currentTime = 0; await demoEl.play(); STATE.videoEl = demoEl; STATE.usingDemo = true; // Установим разумный размер канваса для демо setCanvasSize(1280, 720); await ensureDetector(); STATE.running = true; btnToggle.textContent = 'Stop Camera'; requestDraw(); } catch (e) { console.error('Demo play error:', e); alert('Не удалось запустить демо-видео. ' + (e?.message || e)); } } function stopMediaStream() { if (STATE.stream) { for (const track of STATE.stream.getTracks()) track.stop(); STATE.stream = null; } } function cancelLoop() { if (STATE.rafId) { cancelAnimationFrame(STATE.rafId); STATE.rafId = null; } } function disposeDetector() { if (STATE.detector && STATE.detector.dispose) { STATE.detector.dispose(); } STATE.detector = null; } function stopEverything() { STATE.running = false; cancelLoop(); disposeDetector(); stopMediaStream(); btnToggle.textContent = 'Start Camera'; // Очистим канвас ctx.clearRect(0, 0, canvas.width, canvas.height); peopleEl.textContent = '0'; fpsEl.textContent = '0'; dtEl.textContent = '0'; } function humanizeMediaError(e) { const msg = e?.message || String(e); if (msg.includes('NotAllowedError') || msg.includes('Permission')) { return 'Доступ к камере отклонён. Разрешите доступ к камере в браузере.'; } if (msg.includes('NotFoundError') || msg.includes('OverconstrainedError')) { return 'Камера не найдена или выбранное устройство недоступно.'; } return 'Не удалось получить доступ к камере: ' + msg; } async function ensureDetector() { if (STATE.detector) return; try { const model = poseDetection.SupportedModels.MoveNet; const detectorConfig = { modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING, enableSmoothing: true }; STATE.detector = await poseDetection.createDetector(model, detectorConfig); } catch (e) { console.error('Failed to load detector:', e); alert('Не удалось загрузить модель распознавания поз. Проверьте подключение к интернету.'); throw e; } } // ========================== // Рисование / главный цикл // ========================== function requestDraw() { STATE.rafId = requestAnimationFrame(drawFrame); } async function drawFrame(now) { if (!STATE.running || !STATE.videoEl) return; const v = STATE.videoEl; // Поддерживаем размеры канваса в соответствие с видео (на случай смены камеры/разрешения) if (canvas.width !== v.videoWidth || canvas.height !== v.videoHeight) { setCanvasSize(v.videoWidth, v.videoHeight); } const t0 = performance.now(); let poses = []; try { poses = await STATE.detector.estimatePoses(v, { maxPoses: STATE.maxPoses, flipHorizontal: false }); } catch (e) { console.warn('estimatePoses error:', e); } // Очистка и рендер фона (необязательно — но полезно для отладки) ctx.clearRect(0, 0, canvas.width, canvas.height); // Можно рисовать сам кадр как фон (выключено для производительности, включить при желании): // ctx.drawImage(v, 0, 0, canvas.width, canvas.height); // Рисуем людей const conf = STATE.confThreshold; for (let i = 0; i < poses.length; i++) { const pose = poses[i]; // Генерируем цвет на основе индекса const color = personColor(i); if (STATE.options.showBones) drawSkeleton(pose, conf, color); if (STATE.options.showPoints) drawKeypoints(pose, conf, color); if (STATE.options.showBoxes) drawBox(pose, conf, color); } // Подсчёт FPS/Δt const t1 = performance.now(); STATE.dt = Math.round(t1 - STATE.lastTime); STATE.lastTime = t1; const fps = 1000 / Math.max(1, (performance.now() - t0)); // простая скользящая STATE.fps = Math.round(fps * 0.25 + STATE.fps * 0.75) || Math.round(fps); // Обновим индикаторы peopleEl.textContent = String(poses.length); if (STATE.options.showFPS) { fpsEl.textContent = String(STATE.fps); dtEl.textContent = String(STATE.dt); } else { fpsEl.textContent = '-'; dtEl.textContent = '-'; } requestDraw(); } function personColor(index) { // Детерминированный HSL по индексу const hue = (index * 57) % 360; return `hsl(${hue} 90% 60%)`; } // Пары суставов для костей. MoveNet (17 точек): индексы: // 0:nose,1:leftEye,2:rightEye,3:leftEar,4:rightEar,5:leftShoulder,6:rightShoulder,7:leftElbow, // 8:rightElbow,9:leftWrist,10:rightWrist,11:leftHip,12:rightHip,13:leftKnee,14:rightKnee,15:leftAnkle,16:rightAnkle const EDGES_MOVENET = [ [0,1],[0,2],[1,3],[2,4], // голова/уши/глаза [5,6], // плечи [5,7],[7,9], // левая рука [6,8],[8,10], // правая рука [11,12], // бёдра [5,11],[6,12], // корпус [11,13],[13,15], // левая нога [12,14],[14,16] // правая нога ]; function drawKeypoints(pose, threshold, color) { if (!pose || !pose.keypoints) return; ctx.save(); for (const kp of pose.keypoints) { if (!kp || kp.score == null || kp.score < threshold) continue; const { x, y } = kp; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); } ctx.restore(); } function drawSkeleton(pose, threshold, color) { if (!pose || !pose.keypoints) return; const kps = pose.keypoints; ctx.save(); ctx.lineWidth = 2; ctx.strokeStyle = color; for (const [a, b] of EDGES_MOVENET) { const kp1 = kps[a], kp2 = kps[b]; if (!kp1 || !kp2) continue; if ((kp1.score ?? 0) < threshold || (kp2.score ?? 0) < threshold) continue; ctx.beginPath(); ctx.moveTo(kp1.x, kp1.y); ctx.lineTo(kp2.x, kp2.y); ctx.stroke(); } ctx.restore(); } function drawBox(pose, threshold, color) { if (!pose || !pose.keypoints) return; let xs = [], ys = []; for (const kp of pose.keypoints) { if (!kp || (kp.score ?? 0) < threshold) continue; xs.push(kp.x); ys.push(kp.y); } if (xs.length === 0) return; const minX = Math.min(...xs), maxX = Math.max(...xs); const minY = Math.min(...ys), maxY = Math.max(...ys); const w = maxX - minX, h = maxY - minY; ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.strokeRect(minX - 6, minY - 6, w + 12, h + 12); ctx.restore(); } // ================ // UX улучшения // ================ // Автообновление списка устройств при подключении/отключении камер (не все браузеры поддерживают) if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) { try { navigator.mediaDevices.addEventListener('devicechange', populateCameras); } catch {} } // Очистка ресурсов при закрытии/перезагрузке страницы window.addEventListener('beforeunload', stopEverything, { passive: true }); </script> <!-- ============================== ИНСТРУКЦИИ ПО ЗАПУСКУ ============================== 1) Открыть файл напрямую (двойной клик) — во многих браузерах доступ к камере будет заблокирован (file://). Рекомендуется запускать через локальный сервер. 2) Поднять локальный сервер: - Python 3: python -m http.server 8000 - Node (http-server): npx http-server -p 8000 Затем перейти в браузере на: http://localhost:8000 3) Для мобильных устройств и iOS Safari требуется HTTPS или http://localhost, и разрешить доступ к камере в настройках. 4) Требования: - Современный браузер (Chrome/Edge/Firefox/Safari последних версий). - Подключение к интернету для загрузки скриптов TF.js и модели по CDN. Примечание: - По умолчанию используется MoveNet MultiPose (Lightning) из @tensorflow-models/pose-detection. - Рендеринг выполняется в requestAnimationFrame, вход масштабируется через getUserMedia constraints. --> </body> </html>